\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\renewcommand{\refname}{Bibliografía}
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{url}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Tarea Corta 1\\
{\footnotesize \textsuperscript{}IC3002 - Análisis de Algoritmos}
{\footnotesize \textsuperscript{}Profe.: Yuen Law Wan}
{\footnotesize \textsuperscript{}I Semestre 2020}
}

\author{\IEEEauthorblockN{Joseph Tenorio Pereira}
\IEEEauthorblockA{\textit{2019064588} \\
}
\and
\IEEEauthorblockN{Jose Pablo Muñoz}
\IEEEauthorblockA{\textit{2019061904} \\
}
}

\maketitle

\begin{abstract}
This documentation demonstrates a comparison between the execution time of two popular sorting algorithms used in computer science, specifically the \textit{Bubble Sort} algorithm vs the \textit{Quick Sort} algorithm. The results are presented in a comparative graph created in Unity by measuring the execution time of each algorithm several times and constantly increasing the amount of elements to be sorted by each one. Additionally, the algorithm’s logic is briefly reviewed. 
\end{abstract}


\section{Introducción}
Los algoritmos de ordenamiento nos permiten poner a los elementos de una lista en una secuencia ordenada (por ejemplo una lista numérica de forma ascendente o descendente), lo cual simplifica el trabajo de una amplia variedad de algoritmos que resuelven distintos problemas, como la búsqueda de un elemento en dicha lista. Existen muchos algoritmos de ordenamiento distintos, algunos más complejos que otros, y algunos más eficientes también. Por ende, es importante estar informado del rendimiento de cada uno de ellos para utilizarlos correctamente. 

\section{Descripción de los algoritmos}
A continuación se dará una breve explicación de los algoritmos de ordenamiento analizados por medio
de la graficación en \textit{Unity}. Estos corresponden a los métodos de \textit{Bubble Sort} y \textit{Quick Sort}, programados
en el lenguaje \textit{C\#}. En dicha graficación, se estableció una relación entre la cantidad de elementos a ordenar y
 la cantidad de microsegundos que le toma al algoritmo el realizar dicho ordenamiento. 


\subsection{Algoritmo de ordenamiento Bubble Sort}

El primer método de ordenamiendo analizado corresponde al ordenamiento de burbuja, mejor conocido como \textit{Bubble Sort}.
Este método es una simple e intuitiva solución al problema de acomodar ascendentemente una serie de números. 
Dicha solución consiste en comparar cada número del arreglo con el número siguiente
 (excepto el último número), e intercambiarlos si están en el orden incorrecto. Dicho recorrido, con 
sus respectivas comparaciones e intercambios, se realiza una vez por cada elemento del arreglo
 (como es el caso del algoritmo empleado en este trabajo),o bien, hasta que se realiza un recorrido completo sin intercambios.

\subsection{Algoritmo de ordenamiento Quick Sort}

Por otro lado, el segundo método de ordenamiento analizado corresponde al ordenamiento rápido, mejor conocido
como \textit{Quick Sort}. Este algoritmo pertenece a la categoría de divide y vencerás, en inglés, \textit{Divide and Conquer},
ya que selecciona un elemento del arreglo como pivote y particiona los elementos de dicho arreglo en mayores y menores que el 
pivote, posteriormente se ubica el pivote en la poisición correcta\cite{b1}. El proceso anterior es luego repetido recursivamente sobre
los arreglos resultantes de la partición, hasta que todos ellos queden ordenados. El algoritmo empleado en el presente 
análisis toma como pivote al primer elemento de los arreglos y fue tomado de \cite{b1}.\\

\section{Análisis de resultados}
Como ya se mencionó anteriormente, el gráfico empleado para este trabajo, apreciable en [Fig. 1], establece un relación entre
 el número de elementos a ordenar (eje X) y el tiempo de ejecución (eje Y, en microsegundos) de los algoritmos de
 \textit{Bubble Sort} y \textit{Quick Sort}. Cabe resaltar que para cada tamaño de arreglo (eje X) se realizaron cinco corridas de
cada algoritmo para mejorar la precisión del gráfico. Estas son representadas por los puntos verdes y celestes según sea el caso.

\begin{figure}[htbp]
\centerline{\includegraphics[scale=0.34]{grafico.png}}
\caption{Gráfico resultante en \textit{Unity}.}
\label{fig}
\end{figure}

El primer detalle a notar es el hecho de que el algoritmo \textit{Bubble Sort} se vuelve extremedamente ineficiente conforme
aumenta el tamaño del arreglo a ordenar comparado con el algoritmo \textit{Quick Sort}. De hecho, el algoritmo \textit{Bubble Sort} muesatra un comportamiento exponencial en la graficación ya que su notación O-Grande es de O($n^{2}$). En otro caso, el algoritmo \textit{Quick Sort} podría dar a entender que mantiene un tiempo de ejecución constante, cuando en realidad, el crecimiento del tiempo de ejecución del algoritmo \textit{Quick Sort} no se puede observar en la escala requerida para representar
el crecimiento del algoritmo \textit{Bubble Sort}. Lo anterior se debe a que el método \textit{Quick Sort} presenta un comportamiento logarítmico en su caso promedio, el cual, nuevamente, es imperceptible debido a la magnitud de los valores del eje y. Cabe resaltar que el algoritmo \textit{Quick Sort} podría presentar un comportamiento exponencial de O($n^{2}$) en el peor de los casos.
Otro detalle a notar en los resultados obtenidos es que los tiempos de ejecución del algoritmo de \textit{Bubble Sort} empleado poseen 
una mayor varianza entre pruebas de arreglos de igual tamaño conforme crece el tamaño de dicho arreglo.

\section{Acceso al proyecto}
El repositorio de GitHub en el cual se ubica el proeycto de \textit{Unity} empleado puede ser accesado mediante el siguiente enlace: \url{https://github.com/TilapiaBoi/AnalisisTC1.git}

\begin{thebibliography}{00}
\bibitem{b1} W3resource.com, \textit{C\# Sharp Searching and Sorting Algorithm Exercises: Quick sort}, Nov. 2019. Accesado el: Feb. 21, 2020. [Online]. Disponible en: https://www.w3resource.com/csharp-exercises/searching-and-sorting-algorithm/searching-and-sorting-algorithm-exercise-9.php\\
\bibitem{b2} Code Monkey, \textit{Simple UI Setup (Unity Tutorial for Beginners)}, Jul. 17, 2018. Accesado el: Feb. 23, 2020. [Archivo de video] Disponible en: https://www.youtube.com/watch?v=VHFJgQraVUs\\
\bibitem{b3} Code Monkey, \textit{Unity Tutorial - Create a Graph}, Jun. 22, 2018. Accesado el: Feb. 18, 2020. [Archivo de video] Disponible en: https://www.youtube.com/watch?v=CmU5-v-v1Qo
\end{thebibliography}
\end{document}